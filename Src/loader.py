import numpy as np
import pandas
import cv2
import os

from Src.const import *
from Src.settings import *

     
def load_images_labels(load_test_dataset = False):
    '''
    Loads images and labels for training/testing.\n
    Requires prior preprocessing to work.
    '''
    # Loads paths from the data.csv file
    paths_and_breeds_list, possible_breeds = get_paths_and_breeds(load_test_dataset)
    
    breeds_count = len(possible_breeds)
    doggos_count = len(paths_and_breeds_list)
    
    if DEBUG: doggos_count = 100

    images = np.zeros((doggos_count, IMAGE_SIZE, IMAGE_SIZE, 3))
    labels = np.zeros((doggos_count, breeds_count))

    i = 0
    # Process every image - extract features and create feature vectors
    for doggo_path,doggo_breed in paths_and_breeds_list:

        # Create label [0... 1 ...0] with zeros for all entries except the one corresponding to the breed
        label = np.zeros(breeds_count)
        label[possible_breeds.index(doggo_breed)] = 1

        # Load image, mask, resize them to the same size
        img = cv2.imread(doggo_path)
        
        # Append the data to the datasets
        images[i,:,:,:] = np.array(img)/255
        labels[i,:] = label

        # Looks nice
        print_animated_loader(i,doggos_count)
        i += 1
 
        # If DEBUG is turned on, stops the execution after loading only 100 images
        if DEBUG and i==100: break

    print("\n[INFO] Processing images finished!")

    # Randomly shuffles the data and returns the dataset
    print("[INFO] Shuffling dataset...")
    images, labels = shuffle_images_labels(images,labels)

    print("[INFO] Loading completed!")

    return images, labels, breeds_count

def get_paths_and_breeds(load_test_dataset = False):
    '''
    Extracts paths of the images alongside their corresponding breeds 
    from the CSV file generated by the preprocessor
    '''
    if load_test_dataset: 
        add = "-test"
    else: 
        add = ""

    # Opens the data file
    csv_file = open(PREPRC_PATH+str(IMAGE_SIZE)+add+".csv")
    # Reads it into memory
    csv_data = pandas.read_csv(csv_file, sep = ';')
    
    breed_names = pandas.unique(csv_data['doggo_breed'])

    # Return the list with entries of format (doggo_path, doggo_breed)
    # In addition, return the list of possible breeds 
    return list(zip(
            csv_data['doggo_path'], 
            csv_data['doggo_breed']
    )), breed_names.tolist()

def get_breeds():
    '''
    Returns a list of unique breed names from the 
    CSV file generated by the preprocessor.
    '''
    # Opens the data file
    csv_file = open(PREPRC_PATH+str(IMAGE_SIZE)+".csv")

    # Reads it into memory
    csv_data = pandas.read_csv(csv_file, sep = ';')
    
    breed_names = pandas.unique(csv_data['doggo_breed'])

    # Return the list of possible breeds 
    return breed_names.tolist()

def shuffle_images_labels(images:np.array,labels:np.array):
    '''
    Randomly shuffles images and labels. The applied shuffling is the same
    for both sets, so the image - label matching is perserved
    '''
    
    #Generate a random sequence of indexes without replacement
    randomize = np.arange(labels.shape[0])
    np.random.shuffle(randomize)
    
    #Swap order of the objects in the matrices
    images = images[randomize,:,:,:]
    labels = labels[randomize,:]

    return images, labels

def print_animated_loader(i:int, count:int):
    '''
    A decorative one-line loader.
    '''
    if (i%1000<=250):  c = '\\'
    elif(i%1000<=500): c = '|'
    elif(i%1000<=750): c = '/'
    else:         c = '-'
    
    print("\r[INFO] {} Loading images... {}/{} {}".format(c,i+1,count,c),end="")

def create_required_files_and_folders_if_missing() -> None:
    '''
    Checks if all the required folders and files are created
    and if not, makes them and fills with starting data
    '''
    # Creates the statistics file that will hold trainig results
    if(not os.path.exists(STATS_FILE)):
        f = open(STATS_FILE, 'w')
        f.write(";".join([
            "Model path",
            "Graph path",
            "Accuracy",
            "Loss",
            "Image dim",
            ModelSettings.get_statistics_header_as_string()
        ]))
        f.close()

    # Creates folders for graphs and models
    if(not os.path.exists(GRAPHS_PATH)):
        os.mkdir(GRAPHS_PATH)
    if(not os.path.exists(MODELS_PATH)):
        os.mkdir(MODELS_PATH)

def verify_preprocessing_complete() -> None:
    '''
    Checks if the preprocessing was completed.\n
    Throws an error and stop the program execution if not.
    '''
    print("[INFO] Veryfying if preprocessing completed...")
    s = str(IMAGE_SIZE)

    # Tests for folders genenerated by preprocessor and csv files
    conditions_satisfied = (os.path.exists(IMAGES_PATH) and
        os.path.exists(ANNONS_PATH) and
        os.path.exists(OUTPUTS_PATH+s) and
        os.path.exists(PREPRC_PATH+s+".csv") and 
        os.path.getsize(PREPRC_PATH+s+".csv")>0 and
        len(os.listdir(OUTPUTS_PATH+s))>=len(os.listdir(IMAGES_PATH)))

    if not conditions_satisfied:
        print("[ERR] Preprocessing was not yet completed for {}x{} image size. Please run preprocessor.py before launching this code".format(s,s))
        exit(-1) 

    # Checks if image shape match the ones requested by the CONST file
    test_image_shape = cv2.imread(OUTPUTS_PATH+s+'/'+os.listdir(OUTPUTS_PATH+s)[0]).shape
    if(test_image_shape != (IMAGE_SIZE, IMAGE_SIZE,3)):
        print("[ERR] Image size in const.py ({}) does not match preprocessed images' (folder: {}, test image: {}). Re-leaunch preprocesor to fix this".format(IMAGE_SIZE,s, test_image_shape[0]))
        exit(-1)

    print("[INFO] Success!")
    
def prepare_image_for_evaluation(image_path:str):
    image = cv2.imread(image_path)
    image = cv2.resize(image, (IMAGE_SIZE, IMAGE_SIZE), interpolation=cv2.INTER_CUBIC)
    image = np.reshape(image, (1, IMAGE_SIZE, IMAGE_SIZE, 3))
    image = image/255

    return image

def get_example_images_for_breed(breed:str, count = 2):
    csv_file = open(PREPRC_PATH+str(IMAGE_SIZE)+".csv")
    # Reads it into memory
    csv_data = pandas.read_csv(csv_file, sep = ';')

    filtered_data = csv_data[
                csv_data['doggo_breed'].eq(breed) 
    ]

    filtered_data = filtered_data['doggo_path']
    return filtered_data[:count].tolist()
